#### 练习3: 阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现（不需要编码）

- 简要对 fork/exec/wait/exit函数进行分析。

  1. **`sys_exit`函数：**
     - 该函数用于实现系统调用 `sys_exit`，其目的是让当前进程退出。
     - 通过获取参数中的错误码，然后调用 `do_exit` 函数执行实际的退出操作。
  2. **`sys_fork`函数：**
     - 该函数用于实现系统调用 `sys_fork`，其目的是创建一个新的进程，即进行进程的复制。
     - 获取当前进程的上下文信息（trapframe），然后调用 `do_fork` 函数来完成进程的复制。
  3. **`sys_wait`函数：**
     - 该函数用于实现系统调用 `sys_wait`，其目的是等待子进程的退出。
     - 通过获取参数中的子进程PID和存储状态的指针，然后调用 `do_wait` 函数来等待指定的子进程退出。
  4. **`sys_exec`函数：**
     - 该函数用于实现系统调用 `sys_exec`，其目的是加载一个新的程序执行，替代当前进程的执行。
     - 通过获取参数中的程序名、程序名长度、二进制数据和大小，然后调用 `do_execve` 函数来完成执行新程序的操作。
  5. **`do_fork`函数：**
     - 该函数用于实现进程的复制，包括分配新的 `proc_struct`，分配新的内核堆栈，复制或共享内存管理信息，设置新进程的上下文信息，将新进程插入到进程链表等。
     - 在复制完成后，将新进程设置为可调度状态，并返回新进程的PID。
  6. **`do_exit`函数：**
     - 该函数用于实现进程的退出，包括释放内存空间，处理父进程等待子进程的情况，将进程状态设置为 `PROC_ZOMBIE`，并最终进行调度。
  7. **`do_execve`函数：**
     - 该函数用于执行进程替换操作，包括释放当前进程的内存空间，加载新的程序，设置新的程序名，最终进行调度。
  8. **`do_wait`函数：**
     - 该函数用于实现等待子进程退出的操作，包括查找指定PID的子进程，等待子进程退出，并释放相关资源。

  函数具体执行过程在分析执行流程时再作介绍。





- 请分析fork/exec/wait/exit的执行流程。重点关注哪些操作是在用户态完成，哪些是在内核态完成？内核态与用户态程序是如何交错执行的？内核态执行结果是如何返回给用户程序的？

  执行流程概括如下：

  1. **用户态的系统调用触发：**
     - 用户态的程序通过库函数（如`fork`、`exec`、`wait`、`exit`等）发起系统调用。
     - 库函数会使用特定的指令（例如 `ecall` 指令）来触发一个中断，将控制权转交给操作系统内核。

  2. **异常处理和内核态的系统调用函数：**
     - 中断发生后，操作系统的异常处理程序（异常处理 handler）被调用。
     - 异常处理程序首先保存当前被中断的程序的上下文，包括程序计数器和寄存器状态，通常保存在一个数据结构中，例如 `trapframe`。
     - 异常处理程序设置中断返回地址，然后调用内核态的 `syscall` 函数。

  3. **内核态的 syscall 函数处理：**
     - `syscall` 函数通过检查 `trapframe` 中的系统调用号来确定应该执行哪个系统调用服务函数。
     - 它从 `trapframe` 中获取用户传递的参数，将控制权转交给特定的系统调用服务函数。

  4. **系统调用服务函数执行：**
     - 系统调用服务函数在内核态执行，可以访问用户传递的参数和其他内核数据结构。
     - 服务函数执行相应的操作，可能会调用其他内核函数来完成任务，如进程管理、文件操作等。

  5. **服务函数返回和用户态恢复：**
     - 服务函数执行完毕后，控制权回到 `syscall` 函数。
     - `syscall` 函数将结果（如果有的话）返回到 `trapframe`。
     - `iret` 指令被用来从中断返回，将控制权返回到用户程序。
     - 用户程序恢复执行，并可以检查系统调用的结果。
     
     

  几个过程的具体执行流程：

  `fork` ：

  1. 程序调用 `fork`。

  2. `fork` 使用了系统调用 `SYS_fork`。

  3. `SYS_fork` 主要由 `do_fork` 和 `wakeup_proc` 完成。

  4. `do_fork` 完成以下工作：
     - 分配并初始化进程控制块（`alloc_proc` 函数）。
     
     - 分配并初始化内核栈，为内核进程建立栈空间（`setup_kstack` 函数）。
     
     - 根据 `clone_flag` 标志复制或共享进程内存管理结构（`copy_mm` 函数）。
     
     - 设置进程在内核正常运行和调度所需的中断帧和执行上下文（`copy_thread` 函数）。
     
     - 为进程分配一个 PID（`get_pid()` 函数）。
     
     - 将设置好的进程控制块放入 `hash_list` 和 `proc_list` 两个全局进程链表中。
     
     - 进程准备好执行，状态设置为“就绪”态，`wakeup_proc` 设置进程状态为 RUNNABLE。
     
     - 设置返回码为子进程的 PID 号。
     
       

  `exec` ：

  1. 当应用程序执行时，会调用系统调用 `SYS_exec`。
  2. `SYS_exec` 的功能主要由 `do_execve` 函数实现。
  3. `do_execve` 函数完成以下工作：
     - 为加载新的执行码做好用户态内存空间清空准备。
     - 如果当前进程的内存管理结构 `mm` 不为 `NULL`，则设置页表为内核空间页表，并释放进程所占用的用户空间内存和进程页表本身所占用的空间（如果引用计数减为 0）。
     - 将当前进程的 `mm` 指针置为 `NULL`。
     - 加载应用程序执行码到当前进程的新创建的用户态虚拟空间中。
     - 调用 `load_icode` 使进程准备好执行。

  

  `wait` ：

  1. 当执行 `wait` 功能时，会调用系统调用 `SYS_wait`。
  2. `SYS_wait` 的功能主要由 `do_wait` 函数实现。
  3. `do_wait`函数完成以下工作：
     - 如果 `pid != 0`，表示只找一个进程 ID 号为 `pid` 的退出状态的子进程，否则找任意一个处于退出状态的子进程。
     - 如果找到的子进程的执行状态不为 `PROC_ZOMBIE`，表示子进程还没有退出，当前进程设置执行状态为 `PROC_SLEEPING`（睡眠）并等待子进程退出。
     - 如果找到的子进程的执行状态为 `PROC_ZOMBIE`，表示子进程处于退出状态，当前进程（即子进程的父进程）完成对子进程的最终回收工作，包括从两个进程队列 `proc_list` 和 `hash_list` 中删除子进程的控制块，并释放子进程的内核堆栈和控制块。

  

  `exit` ：

  1. 当执行 `exit` 功能时，会调用系统调用 `SYS_exit`。
  2. `SYS_exit` 的功能主要由 `exit` 函数实现。
  3. `exit` 函数完成以下工作：
     - 调用 `do_exit` 函数回收用户进程占用的用户态虚拟内存空间。
     - 在 `do_exit` 中，首先释放用户虚拟内存空间相关的资源。
     - 设置当前进程的状态为 `PROC_ZOMBIE`，表示进程已退出，同时设置当前进程的退出码为 `error_code`，表示此进程已经无法再被调用，只能等到父进程来回收。
     - 如果父进程处于等待子进程的状态，唤醒父进程，让父进程来回收子进程所占用的资源。
     - 遍历当前进程的所有子进程：
        - 如果当前进程还有子进程，则需要把这些子进程的父进程指针设置为内核线程 `initproc`，并加入 `initproc` 的子进程链表。
        - 如果子进程的执行状态是僵尸状态，提醒 `initproc` 回收这个子进程。
     - 最后执行 `schedule` 函数，切换到其他进程。





- 请给出ucore中一个用户态进程的执行状态生命周期图（包括执行状态，执行状态之间的变换关系，以及产生变换的事件或函数调用）。

```mermaid
graph LR;
  START(( ))-->|alloc_proc| UNINIT
  UNINIT -->|wakeup_proc| RUNNABLE;
  RUNNABLE -->|do_kill| ZOMBIE;
  RUNNING -->|do_exit| ZOMBIE;
  RUNNING -->|do_wait| SLEEPING;
  SLEEPING -->|wakeup_proc| RUNNABLE;
  RUNNABLE <-->|schedule| RUNNING;
```



