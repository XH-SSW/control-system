# 实验报告lab3
## 小组成员：2112430 薛浩，2110137 林楷达，2112557 石轹文


#### 练习一·理解基于FIFO的页面替换算法
* 描述FIFO页面置换算法下，一个页面从被换入到被换出的过程中，会经过代码里哪些函数/宏的处理（或者说，需要调用哪些函数/宏），并用简单的一两句话描述每个函数在过程中做了什么？
在FIFO页面置换算法下，以下是更多函数，它们在页面从被换入到被换出的过程中扮演重要角色：
** 1._fifo_init_mm(struct mm_struct *mm): 初始化FIFO页面置换算法所需的数据结构，包括pra_list_head和mm->sm_priv的设置。
** 2._fifo_map_swappable(struct mm_struct *mm, uintptr_t addr, struct Page *page, int swap_in): 将页面链接到pra_list_head的末尾，以记录页面的访问顺序。
** 3._fifo_swap_out_victim(struct mm_struct *mm, struct Page **ptr_page, int in_tick): 选择要被置换出的页面，从pra_list_head的前端取出并设置ptr_page指向该页面。
** 4._fifo_check_swap(void): 用于检查页面置换情况，尽管主要用于调试，但影响了执行过程。
** 5._fifo_init(void): 用于初始化FIFO页面置换算法，尽管不直接参与页面置换，但在初始化过程中起到了关键作用。
** 6._fifo_set_unswappable(struct mm_struct *mm, uintptr_t addr): 用于将特定页面设置为不可置换，虽然在换入到换出的过程中没有直接作用。
** 7._fifo_tick_event(struct mm_struct *mm): 在FIFO页面置换算法中，用于在每个时钟滴答事件中执行的操作。
** 8.list_init(&pra_list_head): 初始化pra_list_head，确保页面置换算法的数据结构准备就绪。
** 9.list_add(head, entry): 将页面添加到pra_list_head的末尾，记录页面的访问顺序。
** 10.list_del(entry): 从pra_list_head中删除页面，用于选择要被置换出的页面。
** 11.le2page(entry, pra_page_link): 用于将通用链表结构转换为页面结构，以便进行页面的相关操作。
** 12.assert(in_tick==0): 用于断言条件，确保在非时钟滴答事件中执行。



#### 练习二·深入理解不同分页模式的工作原理
* get_pte()函数（位于kern/mm/pmm.c）用于在页表中查找或创建页表项，从而实现对指定线性地址对应的物理页的访问和映射操作。这在操作系统中的分页机制下，是实现虚拟内存与物理内存之间映射关系非常重要的内容。
* get_pte()函数中有两段形式类似的代码， 结合sv32，sv39，sv48的异同，解释这两段代码为什么如此相像。
** 答：sv32，sv39,sv48都是RISC-V里面定义的虚拟内存系统，其中sv32支持32为虚拟内存空间；sv39支持39为虚拟内存空间，对应3级页表；sv48支持48为虚拟内存空间，对应4级页表。
** 第一段代码中pdep1是一级页表的指针，使用pgdir[PDX1(la)]进行索取获取，如果对应的一级页表项不存在（即未设置 PTE_V 位），则创建一个新的物理页，并设置相关的页面表项以及相应的权限标志位。
** 第二段代码中pdep0 是指向二级页表项的指针，通过 ((pde_t *)KADDR(PDE_ADDR(*pdep1)))[PDX0(la)] 进行索引获取。类似地，如果对应的二级页表项不存在（即未设置 PTE_V 位），则创建一个新的物理页，并设置页面表项以及权限标志位。
** 两段代码相似都涉及到了两级页面表的处理，分别为一级页面和二级页面，第二段代码与第一段不同是因为要访问二级页面需要先访问一级页表得到物理地址才能进行索取访问。

* 目前get_pte()函数将页表项的查找和页表项的分配合并在一个函数里，你认为这种写法好吗？有没有必要把两个功能拆开？
** 答：好。页表项的查找与页表项的分配经常一起使用，将两者合并到一起可以使程序更加简洁，减少函数调用的次数，提高运行的效率。



#### 练习三·给未被映射的地址映射上物理页
* 补充完成do_pgfault（mm/vmm.c）函数，给未被映射的地址映射上物理页。设置访问权限 的时候需要参考页面所在 VMA 的权限，同时需要注意映射物理页时需要操作内存控制 结构所指定的页表，而不是内核的页表。
** 请在实验报告中简要说明你的设计实现过程。请回答如下问题：
```
           swap_in(mm, addr, &page);//分配一个内存页并从磁盘上的交换文件加载数据到该内存页
            page_insert(mm->pgdir,page,addr,perm);//建立内存页 page 的物理地址和线性地址 addr 之间的映射
            swap_map_swappable(mm, addr, page, 1);//将页面标记为可交换
            page->pra_vaddr = addr;//跟踪页面映射的线性地址
```
** （1）请描述页目录项（Page Directory Entry）和页表项（Page Table Entry）中组成部分对ucore实现页替换算法的潜在用处。
** 答：在页目录项中，其中一个重要的组成部分是页表基址域（Page Table Base Address），这个域指向页表的基地址。通过扫描页表中的页表项，我们可以获得每一帧（物理页）的占用情况，进而帮助选择哪一个物理页进行替换。在页表项中，其中一个重要的组成部分是存在位（Present Bit），这个位用来指示相应的物理页是否存在。对于实现页替换算法来说，存在位是非常重要的，因为它可以帮助我们判断哪些物理页可以被替换出去。
** （2）如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？
** 答：检测到页访问异常后，硬件会中断当前的指令执行流程，将控制权转移到操作系统内核中的异常处理程序；异常处理程序负责处理页访问异常。它会根据异常类型和异常地址等信息来确定具体的异常原因，并采取相应的措施，如果异常是由于缺页引起的，那么异常处理程序会触发缺页处理流程。它会根据缺页的原因，尝试找到一个可用的物理页进行分配，并更新页目录和页表，如果异常是由于非法访问引起的，比如访问不存在的页面或只读页面进行写操作等，异常处理程序会采取适当的措施，比如终止当前进程或抛出异常。异常处理程序处理完毕后，它会根据需要进行一些清理工作，然后将控制权返回到缺页服务例程继续执行。缺页服务例程会重新执行引起页访问异常的指令。
** （3）数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？
** 答：有对应关系。Page的全局变量的每一项与页表中的页表项是一一对应的关系。每一个页表项包含了与一个物理页相关的信息，同时，页表项中的存在位指示该页表项对应的物理页是否存在，而Page的全局变量中的每一项则表示相应物理页的状态，但是页目录项并没有与Page的全局变量直接的一一对应关系。页目录项是用来指示页表的基址，通过页表基址可以找到页表中的页表项。而页表项与Page的全局变量是一一对应的，通过页表项可以找到相应的物理页。




#### 练习四·补充完成Clock页替换算法
* 通过之前的练习，相信大家对FIFO的页面替换算法有了更深入的了解，现在请在我们给出的框架上，填写代码，实现 Clock页替换算法（mm/swap_clock.c）。(提示:要输出curr_ptr的值才能通过make grade)
** 请在实验报告中简要说明你的设计实现过程。请回答如下问题：
```
     // 初始化pra_list_head为空链表
     list_init(&pra_list_head);
     // 初始化当前指针curr_ptr指向pra_list_head，表示当前页面替换位置为链表头
     curr_ptr = &pra_list_head;
     // 将mm的私有成员指针指向pra_list_head，用于后续的页面替换算法操作
     mm->sm_priv = &pra_list_head;
	 
	 // 将mm->sm_priv赋值给head
    list_entry_t *head=(list_entry_t*) mm->sm_priv;
	//将entry插入到尾节点的前一个节点之后
    list_add(head->prev, entry);
    // 将页面的visited标志置为1，表示该页面已被访问
    page->visited  = 1;
	
	 // 遍历页面链表pra_list_head，查找最早未被访问的页面
        if (curr_ptr == head){  // 由于是将页面page插入到页面链表pra_list_head的末尾，所以pra_list_head制起标识头部的作用，跳过
            curr_ptr = list_next(curr_ptr);
        }
        // 获取当前页面对应的Page结构指针
        curr_page = le2page(curr_ptr, pra_page_link);
        // 如果当前页面未被访问，则将该页面从页面链表中删除，并将该页面指针赋值给ptr_page作为换出页面
        if (curr_page->visited != 1){
            *ptr_page = curr_page;
            cprintf("curr_ptr %p\n",curr_ptr);
            list_del(curr_ptr);
            break;
        }
        // 如果当前页面已被访问，则将visited标志置为0，表示该页面已被重新访问
        if (curr_page->visited == 1){
            curr_page->visited = 0;
        }
        curr_ptr = list_next(curr_ptr);
```
** 比较Clock页替换算法和FIFO算法的不同。
** 答：
** （1）工作原理：FIFO算法：按照页面进入内存的先后顺序进行替换，最先进入内存的页面会最先被替换出去。Clock算法：通过使用一个类似于时钟的数据结构（通常是一个循环链表或数组），将访问位作为一个时钟指针。当页面需要替换时，Clock算法选择当前时钟指针指向的页面，如果该页面的访问位为0则选择该页面进行替换，否则将访问位设置为0继续遍历。
** （2）访问位的使用：FIFO算法：FIFO算法没有使用访问位，只关注页面的进入顺序。Clock算法：Clock算法使用每个页面的访问位来判断是否被访问过。如果页面的访问位为1，则将其置为0，表示页面已经被使用过。
** （3）页面替换策略：FIFO算法：FIFO算法无法识别页面的访问频率或重要性，因此可能会将最常用的页面替换出去。Clock算法：Clock算法尝试更加智能地判断页面的使用情况。当发生页面替换时，Clock算法会考虑访问位，优先选择未被访问过的页面进行替换，以提高命中率。


#### 练习五·阅读代码和实现手册，理解页表映射方式相关知识
* 如果我们采用”一个大页“ 的页表映射方式，相比分级页表，有什么好处、优势，有什么坏处、风险？
1. **减少内存访问开销：** 传统的分页系统中，操作系统需要维护大量的页表项，每次内存访问都需要多次查找这些页表项。而使用大页，映射更多的连续物理内存，减少了页表项的数量，从而降低了内存访问的开销。CPU在访问内存时可以更快地找到对应的物理地址，提高了内存访问速度。

2. **提高 TLB 命中率：** TLB 是一个缓存，存储了虚拟地址到物理地址的映射关系。使用大页可以映射更大的内存范围，减少了TLB缺失的可能性，提高了TLB的命中率。TLB 命中率的提高意味着更多的内存访问可以直接在TLB中解析，而无需访问更慢的内存层次。

3. **降低页表大小：** 大页映射方式减少了页表的大小，因为一个大页只需要一个页表项，而不是多个小页所需的页表项数量。这降低了内存管理数据结构的大小，减小了操作系统维护页表的开销，提高了内核的效率。

4. **提高性能稳定性：** 减少了页表项的数量和页表的大小，可以降低内存访问的时间，从而提高了系统的整体性能。而且，由于TLB命中率的提高，系统的性能稳定性也得到了改善，因为更少的TLB缺失意味着更少的不可预测的性能开销。

5. **适用于大规模内存映射：** 在需要大规模内存映射的应用场景中，例如大型数据库或科学计算应用，使用大页可以更高效地管理大量的内存，减少了页表项的数量，提高了系统的性能和可扩展性。



#### 一个大页的页表映射方式的坏处和风险：

1. **内存碎片和浪费：** 大页的大小是固定的，如果应用程序的内存使用不是刚好符合大页的整数倍，就会产生内存碎片。这意味着一些内存可能被浪费，无法被有效利用。

2. **不足以支持小内存需求：** 如果应用程序需要的内存量比一个大页小，那么整个大页都会被分配给该应用程序。这样就浪费了内存，因为应用程序无法使用大页中未被利用的部分。

3. **交换（换入/换出）开销增加：** 当使用大页时，如果需要将一个大页从内存换出到磁盘上，会导致较大的换出开销。由于大页的大小相对较大，每次换出都需要传输更多的数据到磁盘，增加了I/O操作的负担。

4. **不适用于小型系统：** 在内存相对较小的系统中，采用大页可能会浪费更多的内存，因为小系统无法充分利用大页，导致内存资源被浪费。

5. **不适用于多任务环境：** 在需要支持多个同时运行的应用程序的系统中，大页可能不够灵活。不同的应用程序可能需要不同大小的内存，采用大页会导致内存分配不够灵活，难以满足多任务环境的需求。


### 知识点：
* （1）虚拟内存是计算机操作系统中的一种重要机制，通过将内存分为多个虚拟地址空间以及将虚拟地址映射到物理地址来提高系统的安全性、可靠性和使用效率。
* （2）TLB的作用：
** 虚拟地址到物理地址的映射： 当程序访问内存时，它使用的是虚拟地址。这个虚拟地址需要被转换为对应的物理地址，以便正确地访问内存中的数据。TLB存储了一部分虚拟地址到物理地址的映射，当CPU发出一个虚拟地址时，TLB能够快速地检查是否存在对应的映射。
** 加速内存访问： TLB的存在减少了在内存访问时进行完整的页表查找的需要，因为它提供了快速的虚拟地址到物理地址的转换。这样，如果TLB中存在所需的映射，CPU就能够迅速地访问相应的物理地址，而不必等待完整的页表查找。
** 减少内存访问的延迟： TLB命中（即在TLB中找到了虚拟地址到物理地址的映射）会显著减少内存访问的延迟，因为不再需要在主存中进行昂贵的查找操作。

* （3）TLB的结构：
** TLB通常是一个小而快速的硬件缓存，位于CPU内部或者紧密集成在内存管理单元（MMU）中。它包含了多个条目，每个条目存储了虚拟地址到物理地址的映射。每当CPU访问内存时，TLB会被查询，如果找到了对应的映射，就会产生一个TLB命中。

* （4）TLB的问题：
** TLB缺失（TLB Miss）： 如果CPU发出一个虚拟地址，而在TLB中找不到对应的映射，就会导致TLB缺失。这时，系统必须在页表中进行查找，找到对应的物理地址，然后将这个映射添加到TLB中。TLB缺失会引起较大的性能开销，因为需要额外的内存访问操作。
** TLB更新： 当操作系统进行内存管理操作，比如页表的更新时，可能会导致TLB中的某些映射变得无效。这时，TLB需要被更新，以避免引用了无效的映射。TLB的更新可能需要较多的时间，尤其是在高并发系统中。
** TLB一致性： 在多处理器系统中，多个CPU可能共享同一个内存空间。这时，TLB的一致性就成为了一个挑战，因为一个CPU的TLB更新可能会影响到其他CPU的内存访问。
* （5）缺页异常是指CPU访问的虚拟地址时， MMU没有办法找到对应的物理地址映射关系，或者与该物理页的访问权不一致而发生的异常。
* （6）时钟（Clock）页替换算法：是 LRU 算法的一种近似实现。时钟页替换算法把各个页面组织成环形链表的形式，类似于一个钟的表面。然后把一个指针（简称当前指针）指向最老的那个页面，即最先进来的那个页面。另外，时钟算法需要在页表项（PTE）中设置了一位访问位来表示此页表项对应的页当前是否被访问过。当该页被访问时，CPU 中的 MMU 硬件将把访问位置“1”。当操作系统需要淘汰页时，对当前指针指向的页所对应的页表项进行查询，如果访问位为“0”，则淘汰该页，如果该页被写过，则还要把它换出到硬盘上；如果访问位为“1”，则将该页表项的此位置“0”，继续访问下一个页。

