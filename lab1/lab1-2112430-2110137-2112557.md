# 实验报告lab0.5与lab1

## 成员：2112430 薛浩， 2110137 林楷达， 2112557 石轹文

### lab0.5
#### 1.练习1.使用GDB验证启动流程

*  说明RISC-V硬件加电后的几条指令在哪里？完成了哪些功能？
** 答：加电后的指令于0x1000开始，
** 五条汇编语言：
***
* （1）**0x1000: auipc	t0,0x0** ：将PC的高 20 位偏移量设置为0x0，并将结果存储在寄存器 t0 中，使得此时 t0 的值是 0x1000。
* （2）**0x1004:	addi	a1,t0,32** ：将寄存器 t0 的值与立即数32相加，并将结果存储在寄存器 a1 中，此时 a1 的值是0x1020。
* （3）**0x1008:	csrr	a0,mhartid**：读取 mhartid 寄存器的值，并把结果储存在寄存器 a0 中，其中CSRR是一个特权级别下的指令，用于读取 CSR的值。
* （4）**0x100c:	ld	t0,24(t0)**： 从 t0 中取出地址加上偏移量24 ，并将结果存储在寄存器 t0 中，那个地址保存的数据就是0x80000000
* （5）**0x1010:	jr	t0** ： 跳转到寄存器 t0 中存储的地址，完成地址的转移。

将 PC寄存器跳转到0x80000000处，并于该处将文件被加载到Qemu的物理内存中，转入到OpenSBI的启动流程，然后跳转至0x80200000，最后由内核程序执行。同时本实验实现了处理器的复位；执行memset函数时，对内存的初始化；通过BootLoader加载操作系统；对程序入口点的跳转。
***
#### 2.重要知识点：
* （1）bootloader可以初始化系统硬件并启动操作系统内核，解决操作系统不能将自己加载到内存里的问题。
* （2）最小可执行内核的执行流为:加电 -> OpenSBI启动 -> 跳转到 0x80200000 ->进入kern_init()函数->调用cprintf()输出一行信息->结束
* （3）RISC-V的入口函数地址一般固定为0x80000000。
* （4）操作系统可以对进程进行创建、调度、暂停、恢复和终止等操作，同时也需要确保进程之间的资源共享和互斥，以避免冲突和竞争条件。
#### 3.练习过程简述：
* （1）打开lab0文件夹之后，同时开启两个终端，分别输入make debug与make gdb;
* （2）输入x/10i 0x80000000查阅此处的汇编代码；
* （3）输入x/10i $pc查阅即将执行的汇编指令；
* （4）输入b *0x80000000,于此处设置断点；
* （5）输入c使其执行到断点，可以看到RISC-V没有反应；
* （6）输入b *0x80200000于此处设置断点；
* （7）输入c使其执行到断点，可以看到kern_init函数完成执行，说明操作系统启动。


### lab1
#### 1.练习1

* 阅读 kern/init/entry.S内容代码，结合操作系统内核启动流程，说明指令 la sp, bootstacktop 完成了什么操作，目的是什么？ tail kern_init 完成了什么操作，目的是什么？
** 答：la sp, bootstacktop完成了修改栈指针寄存器sp为 .data 段的结束地址的操作，这么操作的理由是栈从高地址往低地址增长；tail kern_init实现了跳转到kern_init函数的操作，目的是从内核运行的环境设置正式进入内核。
#### 2.练习2

* 请编程完善trap.c中的中断处理函数trap，在对时钟中断进行处理的部分填写kern/trap/trap.c函数中处理时钟中断的部分，使操作系统每遇到100次时钟中断后，调用print_ticks子程序，向屏幕上打印一行文字”100 ticks”，在打印完10行后调用sbi.h中的shut_down()函数关机。
** 答：具体代码如下：
```
 clock_set_next_event();//设置下次时钟中断- clock_set_next_event()
            ticks++;//计数器（ticks）加一
            if(ticks%100==0){
            print_ticks();
            num++;
	}//在if语句中当计数器为100的倍数时，会输出一个100ticks表示触发了100次时钟中断，同时打印次数（num）加一
	if(num==10){
	sbi_shutdown();
}//判断打印次数，当打印次数num为10时，调用<sbi.h>中的关机函数sbi_shutdown()关机
```
#### 3.Challenge1 描述与理解中断流程

* 答：
** （1）ucore中处理中断异常的流程（从异常的产生开始）：首先set_sbi_timer()通过时钟事件触发中断，然后跳转到trapentry.S的__alltraps，之后通过函数调用，进入trap()的执行流，利用函数调用切换前的上下文被传递给trap()作为函数参数 ，之后trap.c按照中断类型进行分发，随后执行时钟中断对应的处理语句，完成累加计数器，并设置下一次时钟中断，最后完成处理返回到trapentry.S并恢复原先的上下文。
** （2）mov a0，sp的目的：将当前栈顶地址sp的值给到寄存器a0；
** （3）SAVE_ALL中寄寄存器保存在栈中的位置是什么确定的：通过addi sp, sp, -36 * REGBYTES指令预先分配栈帧来确定；
** （4）对于任何中断，__alltraps 中都需要保存所有寄存器吗？请说明理由：不需要，理由是badaddr寄存器和cause寄存器中保存的分别是出错的地址以及出错的原因，在处理完中断时，这两个寄存器的内容并不被需要，因此不用保存所有寄存器。

#### 4.Challenge2 理解上下文切换机制
* 答：
** （1）在trapentry.S中汇编代码 csrw sscratch, sp；csrrw s0, sscratch, x0实现了什么操作，目的是什么：csrw sscratch, sp实现把栈顶地址sp赋给sscratch,而csrrw s0, sscratch, x0实现把sscratch的值保存在s0中，同时清零sscratch；目的是保证中断向量知道出现的嵌套中断来自内核态。
** （2）save all里面保存了stval scause这些csr，而在restore all里面却不还原它们？那这样store的意义何在呢：badaddr寄存器和cause寄存器中保存的分别是出错的地址以及出错的原因，在还原时不需要还原这两者；store的意义是使内核的C代码可以读取这些CSR。

#### 5.Challenge3 完善异常中断
* 编程完善在触发一条非法指令异常 mret和，在 kern/trap/trap.c的异常处理函数中捕获，并对其进行处理，简单输出异常类型和异常指令触发地址
* 答：具体代码如下：
```
 // 非法指令异常处理
             /* LAB1 CHALLENGE3   2112430，2110137，2112557:  */
            /*(1)输出指令异常类型（ Illegal instruction）
             *(2)输出异常指令地址
             *(3)更新 tf->epc寄存器
            */
            cprintf("Exception type:Illegal instruction\n");
             cprintf("Illegal instruction caught at 0x%016llx\n", tf->epc);
              tf->epc += 2;     //更新 tf->epc寄存器
//断点异常处理
            /* LAB1 CHALLLENGE3   2112430，2110137，2112557 :  */
            /*(1)输出指令异常类型（ breakpoint）
             *(2)输出异常指令地址
             *(3)更新 tf->epc寄存器
            */
             cprintf("Exception type:breakpoint\n");
             cprintf("ebreak caught at 0x%016llx\n", tf->epc);
              tf->epc += 2;     //更新 tf->epc寄存器
```
#### 6.重要知识点：
* （1）sscratch寄存器在处理用户态程序的中断时才起作用；
* （2）C语言里面的结构体，是若干个变量在内存里直线排列；
* （3）中断机制需要软件硬件一起来支持，硬件进行中断和异常的发现，然后交给软件来进行处理。
#### 7.与参考答案的区别
* 参考答案里面没有涉及到打印次数num的问题，在判断ticks是否为100的倍数时采用更简便的表达方式；参考答案中也没有涉及到异常类型（ Illegal instruction）。